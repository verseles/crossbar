import 'dart:io';

import 'package:path/path.dart' as path;

/// Service for scaffolding new plugins
class PluginScaffolding {
  const PluginScaffolding();

  /// Supported languages for plugin scaffolding
  static const List<String> supportedLanguages = [
    'bash',
    'python',
    'node',
    'dart',
    'go',
    'rust',
  ];

  /// Supported plugin types
  static const List<String> supportedTypes = [
    'clock',
    'monitor',
    'status',
    'api',
    'custom',
  ];

  /// Default refresh intervals for each type
  static const Map<String, String> typeIntervals = {
    'clock': '1s',
    'monitor': '10s',
    'status': '30s',
    'api': '5m',
    'custom': '1m',
  };

  /// File extensions for each language
  static const Map<String, String> langExtensions = {
    'bash': 'sh',
    'python': 'py',
    'node': 'js',
    'dart': 'dart',
    'go': 'go',
    'rust': 'rs',
  };

  /// Create a new plugin from template
  Future<String?> createPlugin({
    required String lang,
    required String type,
    String? name,
    String? outputDir,
  }) async {
    // Validate language
    final normalizedLang = lang.toLowerCase();
    if (!supportedLanguages.contains(normalizedLang)) {
      return null;
    }

    // Validate type
    final normalizedType = type.toLowerCase();
    if (!supportedTypes.contains(normalizedType)) {
      return null;
    }

    // Generate plugin name
    final pluginName = name ?? 'my-$normalizedType';
    final interval = typeIntervals[normalizedType] ?? '1m';
    final ext = langExtensions[normalizedLang]!;
    final fileName = '$pluginName.$interval.$ext';

    // Determine output directory
    final homeDir = Platform.environment['HOME'] ??
        Platform.environment['USERPROFILE'] ??
        '.';
    final pluginsDir = outputDir ?? path.join(homeDir, '.crossbar', 'plugins');

    // Create directory if needed
    await Directory(pluginsDir).create(recursive: true);

    // Generate plugin content
    final content = _generateTemplate(normalizedLang, normalizedType, pluginName);
    final filePath = path.join(pluginsDir, fileName);

    // Write plugin file
    await File(filePath).writeAsString(content);

    // Make executable on Unix
    if (Platform.isLinux || Platform.isMacOS) {
      await Process.run('chmod', ['+x', filePath]);
    }

    // Generate config file
    final configContent = _generateConfig(pluginName, normalizedType);
    final configPath = '$filePath.config.json';
    await File(configPath).writeAsString(configContent);

    return filePath;
  }

  /// Generate template content for a plugin
  String _generateTemplate(String lang, String type, String name) {
    switch (lang) {
      case 'bash':
        return _bashTemplate(type, name);
      case 'python':
        return _pythonTemplate(type, name);
      case 'node':
        return _nodeTemplate(type, name);
      case 'dart':
        return _dartTemplate(type, name);
      case 'go':
        return _goTemplate(type, name);
      case 'rust':
        return _rustTemplate(type, name);
      default:
        return _bashTemplate(type, name);
    }
  }

  String _bashTemplate(String type, String name) {
    return '''#!/bin/bash
# $name - $type plugin
# Generated by Crossbar

# Your plugin logic here
value="OK"

# Determine color based on status
if [ "\$value" = "OK" ]; then
    color="green"
else
    color="red"
fi

# Output in BitBar format
echo "✓ \$value | color=\$color"
echo "---"
echo "Plugin: $name"
echo "Type: $type"
echo "---"
echo "Refresh | refresh=true"
''';
  }

  String _pythonTemplate(String type, String name) {
    return '''#!/usr/bin/env python3
# $name - $type plugin
# Generated by Crossbar

import json
import sys

def main():
    # Your plugin logic here
    value = "OK"

    # Simple text output
    if value == "OK":
        color = "green"
    else:
        color = "red"

    print(f"✓ {value} | color={color}")
    print("---")
    print(f"Plugin: $name")
    print(f"Type: $type")
    print("---")
    print("Refresh | refresh=true")

if __name__ == "__main__":
    main()
''';
  }

  String _nodeTemplate(String type, String name) {
    return '''#!/usr/bin/env node
// $name - $type plugin
// Generated by Crossbar

function main() {
    // Your plugin logic here
    const value = "OK";

    // Determine color
    const color = value === "OK" ? "green" : "red";

    // Output in BitBar format
    console.log(\`✓ \${value} | color=\${color}\`);
    console.log("---");
    console.log("Plugin: $name");
    console.log("Type: $type");
    console.log("---");
    console.log("Refresh | refresh=true");
}

main();
''';
  }

  String _dartTemplate(String type, String name) {
    return '''#!/usr/bin/env dart
// $name - $type plugin
// Generated by Crossbar

void main() {
  // Your plugin logic here
  final value = 'OK';

  // Determine color
  final color = value == 'OK' ? 'green' : 'red';

  // Output in BitBar format
  print('✓ \$value | color=\$color');
  print('---');
  print('Plugin: $name');
  print('Type: $type');
  print('---');
  print('Refresh | refresh=true');
}
''';
  }

  String _goTemplate(String type, String name) {
    return '''// +build ignore

package main

// $name - $type plugin
// Generated by Crossbar

import "fmt"

func main() {
	// Your plugin logic here
	value := "OK"

	// Determine color
	color := "green"
	if value != "OK" {
		color = "red"
	}

	// Output in BitBar format
	fmt.Printf("✓ %s | color=%s\\n", value, color)
	fmt.Println("---")
	fmt.Println("Plugin: $name")
	fmt.Println("Type: $type")
	fmt.Println("---")
	fmt.Println("Refresh | refresh=true")
}
''';
  }

  String _rustTemplate(String type, String name) {
    return '''// $name - $type plugin
// Generated by Crossbar

fn main() {
    // Your plugin logic here
    let value = "OK";

    // Determine color
    let color = if value == "OK" { "green" } else { "red" };

    // Output in BitBar format
    println!("✓ {} | color={}", value, color);
    println!("---");
    println!("Plugin: $name");
    println!("Type: $type");
    println!("---");
    println!("Refresh | refresh=true");
}
''';
  }

  String _generateConfig(String name, String type) {
    return '''{
  "name": "$name",
  "version": "1.0.0",
  "description": "A $type plugin generated by Crossbar",
  "author": "",
  "settings": [
    {
      "key": "EXAMPLE_SETTING",
      "type": "text",
      "label": "Example Setting",
      "default": "",
      "required": false
    }
  ]
}
''';
  }
}

/// Service for installing plugins from GitHub
class PluginInstaller {
  const PluginInstaller();

  /// Install a plugin from a GitHub URL
  Future<String?> installFromGitHub(String url) async {
    try {
      // Parse GitHub URL
      final uri = Uri.parse(url);
      if (!uri.host.contains('github.com')) {
        return null;
      }

      // Extract owner/repo from path
      final pathSegments = uri.pathSegments;
      if (pathSegments.length < 2) {
        return null;
      }

      final repo = pathSegments[1].replaceAll('.git', '');

      // Determine plugins directory
      final homeDir = Platform.environment['HOME'] ??
          Platform.environment['USERPROFILE'] ??
          '.';
      final pluginsDir = path.join(homeDir, '.crossbar', 'plugins');

      // Ensure plugins dir exists
      await Directory(pluginsDir).create(recursive: true);

      // Target directory for the repo
      final targetDir = path.join(pluginsDir, repo);

      // Remove existing clone if any
      if (await Directory(targetDir).exists()) {
        await Directory(targetDir).delete(recursive: true);
      }

      final cloneResult = await Process.run(
        'git',
        ['clone', '--depth', '1', url, targetDir],
      );

      if (cloneResult.exitCode != 0) {
        return null;
      }

      // Find plugin files in cloned repo to validate and chmod
      final cloneDir = Directory(targetDir);
      final pluginFiles = <File>[];

      await for (final entity in cloneDir.list(recursive: true)) {
        if (entity is File) {
          final ext = path.extension(entity.path).toLowerCase();
          if (['.sh', '.py', '.js', '.dart', '.go', '.rs'].contains(ext)) {
            // Check if filename matches plugin pattern (name.interval.ext)
            final fileName = path.basename(entity.path);
            if (RegExp(r'\.\d+[smh]\.').hasMatch(fileName)) {
              pluginFiles.add(entity);
            }
          }
        }
      }

      if (pluginFiles.isEmpty) {
        // Clean up - no valid plugins found
        await Directory(targetDir).delete(recursive: true);
        return null;
      }

      // Make executable
      if (Platform.isLinux || Platform.isMacOS) {
        for (final file in pluginFiles) {
          await Process.run('chmod', ['+x', file.path]);
        }
      }

      return targetDir;
    } catch (e) {
      return null;
    }
  }
}
